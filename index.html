<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Protótipo Automático con ML: Detección de Patrones Emergentes</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin:0; background:#0a1226; color:#cfd9e9;
    display: flex; flex-direction: column; height: 100vh;
  }
  header {
    background:#061126; padding: 0.5rem 1rem; font-weight: bold; font-size: 1.2rem;
  }
  main {
    display:flex; flex:1; overflow:hidden;
  }
  #leftPanel {
    width:350px; background:#0d1839; padding:1rem; overflow-y:auto;
    box-shadow: inset -3px 0 6px #021026;
  }
  #rightPanel {
    flex:1; display:flex; flex-direction: column;
  }
  #canvasContainer {
    flex:1; background:#07152f;
    display:flex; justify-content:center; align-items:center;
  }
  canvas {
    background:#0a1a3c; border-radius:12px;
    max-width: 100%; max-height: 100%;
  }
  button {
    background:#2a62bf; border:none; color:#dde6f5;
    padding:0.5rem 1rem; margin-top:1rem;
    cursor:pointer; border-radius:8px;
  }
  button:disabled {
    background:#4c7dc9aa;
    cursor: not-allowed;
  }
  h2 {
    margin-top: 0;
  }
  .alert {
    background:#f45c5c; padding:0.5rem; border-radius:6px; margin-top:0.5rem; font-weight: bold;
    color:#fff;
  }
  .log {
    background:#07172f; border-radius:8px; padding:8px; height: 180px; overflow-y: auto; font-family: monospace; font-size: 12px;
    margin-top: 0.5rem;
  }
  .stat {
    margin-top: 0.4rem;
  }
  #clustersPlot {
    margin-top: 1rem;
    height: 180px;
    background: #0b1b3a;
    border-radius: 10px;
    padding: 6px;
    font-size: 12px;
    overflow-x: auto;
    white-space: nowrap;
  }
</style>
</head>
<body>
<header>Protótipo Automático + ML: Detección de Patrones Emergentes</header>
<main>
  <section id="leftPanel">
    <h2>Controles</h2>
    <div>
      <button id="btnStart">Iniciar Exploración Automática</button>
      <button id="btnStop" disabled>Detener</button>
      <button id="btnExport" disabled>Exportar Datos CSV</button>
    </div>

    <h3>Estado</h3>
    <div class="stat">Simulaciones totales: <span id="totalSims">0</span></div>
    <div class="stat">Simulación actual: <span id="currentSim">0</span></div>
    <div class="stat">Alertas ML: <span id="mlAlertsCount">0</span></div>

    <h3>Alertas Detectadas</h3>
    <div id="alerts" class="log" aria-live="polite" aria-atomic="true"></div>

    <h3>Clusters y Análisis</h3>
    <div id="clustersPlot">(Gráfico de clusters aparecerá aquí)</div>
  </section>

  <section id="rightPanel">
    <div id="canvasContainer">
      <canvas id="canvas" width="600" height="600"></canvas>
    </div>
  </section>
</main>

<script>
(() => {
  // --- Parámetros y Configuración ---
  const paramGrid = {
    alpha: [0, 0.5, 1, 1.5, 2],
    beta: [0, 0.05, 0.1, 0.2],
    kappa: [0, 0.05, 0.1, 0.15],
    Uth: [0.05, 0.08, 0.12],
    dr: [0.01, 0.03, 0.05]
  };
  const seedsCount = 3;      // cantidad de seeds (variación aleatoria)
  const stepsPerSim = 500;   // pasos de simulación por corrida
  const N = 256;             // nodos de la simulación

  // Estado UI
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const btnExport = document.getElementById('btnExport');
  const totalSimsSpan = document.getElementById('totalSims');
  const currentSimSpan = document.getElementById('currentSim');
  const mlAlertsCountSpan = document.getElementById('mlAlertsCount');
  const alertsDiv = document.getElementById('alerts');
  const clustersPlot = document.getElementById('clustersPlot');

  // Canvas y contexto
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Variables de simulación
  let s, U, Uprev, u, uprev, v, r, theta;
  let isRunning = false;

  // Logs y datos para ML
  let logs = [];
  let mlAlertsCount = 0;

  // --- Funciones básicas simulación ---
  function initArrays(cfg, seed) {
    s = new Float64Array(N);
    U = new Float64Array(N);
    Uprev = new Float64Array(N);
    u = new Float64Array(N);
    uprev = new Float64Array(N);
    v = new Float64Array(N);
    r = new Float64Array(N);
    theta = new Float64Array(N);
    for(let j=0; j<N; j++) {
      s[j] = j;
      U[j] = (Math.random()-0.5)*0.02*seed;
      Uprev[j] = U[j];
      u[j] = 0;
      uprev[j] = 0;
      v[j] = 0;
      theta[j] = (j/(N-1))*cfg.thetaTot;
      r[j] = cfg.a*theta[j];
    }
  }

  // Operadores discretos
  function grad(arr,j){
    if(j<=0) return arr[1]-arr[0];
    if(j>=arr.length-1) return arr[arr.length-1]-arr[arr.length-2];
    return (arr[j+1]-arr[j-1])/2;
  }
  function lap(arr,j){
    if(j<=0) return arr[1]-2*arr[0]+arr[0];
    if(j>=arr.length-1) return arr[arr.length-1]-2*arr[arr.length-2]+arr[arr.length-1];
    return arr[j+1]-2*arr[j]+arr[j-1];
  }

  // Simulación por paso
  function step(cfg, dt){
    const N = cfg.N;
    const eps = new Float64Array(N);
    const c = new Float64Array(N);
    for(let j=0;j<N;j++) {
      const divu = grad(u,j);
      eps[j] = 1.0 + cfg.alpha*divu + cfg.beta*U[j]*U[j];
      c[j] = 1/Math.sqrt(eps[j]);
    }
    const newU = new Float64Array(N);
    for(let j=1;j<N-1;j++) {
      const lapU = lap(U,j);
      const dUd = (U[j] - Uprev[j])/dt;
      newU[j] = 2*U[j] - Uprev[j] + dt*dt*(c[j]*c[j]*lapU - 2*cfg.gamma*dUd) - dt*dt*cfg.kappa*U[j];
    }
    newU[0] = 0;
    newU[N-1] = 0;

    for(let j=1;j<N-1;j++) {
      if(Math.abs(newU[j]-U[j]) > cfg.Uth) cfg.jumps++;
    }

    for(let j=0;j<N;j++) {
      Uprev[j] = U[j];
      U[j] = newU[j];
    }

    // Actualizar u con ecuación acoplada simplificada
    for(let j=1;j<N-1;j++) {
      const lapu = lap(u,j);
      const T = U[j]*U[j];
      const dtt_u = lapu + T;
      u[j] += dt*dt*dtt_u - dt*cfg.eta*u[j];
    }
  }

  // Extraer características para ML
  function extractFeatures(log){
    // Feature vector: [maxEnergy, focalDuration, jumps, entropy]
    // Entropía simple: -sum(p*log(p)) con p normalizado de |U|
    const Uabs = log.U.map(x => Math.abs(x));
    const maxEnergy = Math.max(...Uabs);
    const focalDuration = log.focalDuration;
    const jumps = log.jumps;

    // Normalizar para prob
    const sumU = Uabs.reduce((a,b)=>a+b,0);
    const p = Uabs.map(x=>x/sumU);
    let entropy = 0;
    for(let v of p){
      if(v>0) entropy -= v*Math.log(v);
    }

    return [maxEnergy, focalDuration, jumps, entropy];
  }

  // K-means simple
  function kmeans(data, k, maxIter=50) {
    // Init random centers
    const centers = [];
    for(let i=0;i<k;i++) {
      centers.push(data[Math.floor(Math.random()*data.length)].slice());
    }

    let labels = new Array(data.length).fill(0);
    for(let iter=0;iter<maxIter;iter++) {
      // Assign
      for(let i=0;i<data.length;i++) {
        let bestDist = Infinity;
        let bestC = 0;
        for(let c=0;c<k;c++) {
          let dist = 0;
          for(let d=0;d<data[i].length;d++) {
            dist += (data[i][d]-centers[c][d])**2;
          }
          if(dist<bestDist){
            bestDist=dist;
            bestC=c;
          }
        }
        labels[i] = bestC;
      }
      // Update centers
      const sums = Array(k).fill(null).map(()=>Array(data[0].length).fill(0));
      const counts = Array(k).fill(0);
      for(let i=0;i<data.length;i++) {
        const c = labels[i];
        counts[c]++;
        for(let d=0;d<data[0].length;d++) {
          sums[c][d]+=data[i][d];
        }
      }
      for(let c=0;c<k;c++){
        if(counts[c]>0){
          for(let d=0;d<data[0].length;d++){
            centers[c][d] = sums[c][d]/counts[c];
          }
        }
      }
    }
    return {centers, labels};
  }

  // Detectar outliers por cluster pequeño (<= umbral)
  function detectOutliers(labels, minClusterSize=2){
    const counts = {};
    for(let l of labels){
      counts[l] = (counts[l]||0)+1;
    }
    const outliersIdx = [];
    labels.forEach((lab,i)=>{
      if(counts[lab]<=minClusterSize) outliersIdx.push(i);
    });
    return outliersIdx;
  }

  // Variables para simulación
  let cfg = {
    N,
    alpha: 0,
    beta: 0,
    kappa: 0,
    gamma: 0.02,
    eta: 0.02,
    Uth: 0.08,
    dr: 0.03,
    a: 1,
    thetaTot: 16,
    jumps: 0
  };

  // Iniciar simulación para parámetros y seed dados
  async function runSimulation(params, seed) {
    [cfg.alpha, cfg.beta, cfg.kappa, cfg.Uth, cfg.dr] = params;
    cfg.jumps = 0;
    initArrays(cfg, seed);

    let focalDuration = 0;
    let maxEnergy = 0;

    for(let i=0;i<stepsPerSim;i++){
      step(cfg, 0.002);

      const currentMax = Math.max(...U.map(x=>Math.abs(x)));
      if(currentMax>maxEnergy) maxEnergy=currentMax;

      if(currentMax>cfg.Uth) focalDuration++;
      else if(focalDuration>0) focalDuration=0;

      if(i%100===0) await new Promise(r=>setTimeout(r,0)); // no bloquear UI
    }

    return {
      params,
      seed,
      maxEnergy,
      focalDuration,
      jumps: cfg.jumps,
      U: Array.from(U),
    };
  }

  // Función para dibujar la espiral con deformaciones
  function drawSimulation() {
    ctx.clearRect(0,0,W,H);
    ctx.lineWidth = 1.8;
    ctx.strokeStyle = 'cyan';
    ctx.beginPath();
    for(let j=0;j<N;j++){
      const angle = theta[j];
      const rad = r[j] + 20*U[j];
      const x = W/2 + rad*Math.cos(angle);
      const y = H/2 + rad*Math.sin(angle);
      if(j===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // puntos saltos en rojo
    ctx.fillStyle = 'red';
    for(let j=1;j<N-1;j++) {
      if(Math.abs(U[j]-Uprev[j]) > cfg.Uth){
        const angle = theta[j];
        const rad = r[j] + 20*U[j];
        const x = W/2 + rad*Math.cos(angle);
        const y = H/2 + rad*Math.sin(angle);
        ctx.beginPath();
        ctx.arc(x,y,3,0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  // Variables para el loop principal
  let currentSimulationIndex = 0;
  let allParamCombinations = [];
  let simulationData = [];

  // Generar combinaciones cartesianas
  function cartesian(arrays){
    if(arrays.length===0) return [[]];
    const rest = cartesian(arrays.slice(1));
    const result = [];
    for(const v of arrays[0]){
      for(const r of rest){
        result.push([v,...r]);
      }
    }
    return result;
  }

  function logAlert(text){
    mlAlertsCount++;
    mlAlertsCountSpan.textContent = mlAlertsCount;
    const time = new Date().toLocaleTimeString();
    alertsDiv.textContent = time + ' - ' + text + '\n' + alertsDiv.textContent;
  }

  // Función principal para correr todas simulaciones y analizar
  async function runAllSimulations() {
    btnStart.disabled = true;
    btnStop.disabled = false;
    btnExport.disabled = false;

    allParamCombinations = cartesian([
      paramGrid.alpha,
      paramGrid.beta,
      paramGrid.kappa,
      paramGrid.Uth,
      paramGrid.dr
    ]);
    const totalSimsCount = allParamCombinations.length * seedsCount;
    totalSimsSpan.textContent = totalSimsCount;
    currentSimSpan.textContent = '0';
    mlAlertsCountSpan.textContent = '0';

    simulationData = [];
    mlAlertsCount = 0;

    isRunning = true;

    for(let i=0; i<allParamCombinations.length && isRunning; i++) {
      for(let seed=1; seed<=seedsCount && isRunning; seed++) {
        currentSimulationIndex++;
        currentSimSpan.textContent = currentSimulationIndex;
        const simResult = await runSimulation(allParamCombinations[i], seed);
        simulationData.push(simResult);

        // Extraer features para ML
        const features = extractFeatures(simResult);
        simResult.features = features;

        // Mostrar simulación más reciente en canvas
        // Actualizar estados globales para dibujo
        for(let j=0;j<N;j++) {
          U[j] = simResult.U[j];
          Uprev[j] = U[j];  // para evitar saltos falsos al dibujar
          theta[j] = (j/(N-1))*cfg.thetaTot;
          r[j] = cfg.a*theta[j];
        }
        drawSimulation();

        // Al final de cada simulación hacemos clustering de todos los datos
        if(simulationData.length >= 20) {
          // Aplicar K-means con 3 clusters (puedes cambiar k)
          const allFeatures = simulationData.map(s => s.features);
          const kmres = kmeans(allFeatures, 3);
          const outliersIdx = detectOutliers(kmres.labels);

          // Mostrar clusters (texto simple)
          let clusterSummary = '';
          for(let c=0;c<3;c++){
            const count = kmres.labels.filter(l=>l===c).length;
            clusterSummary += `Cluster ${c+1}: ${count} muestras &nbsp;&nbsp;&nbsp;`;
          }
          clustersPlot.innerHTML = clusterSummary;

          // Alertar sobre outliers detectados
          if(outliersIdx.length>0) {
            for(let idx of outliersIdx){
              const s = simulationData[idx];
              logAlert(`Posible patrón raro (outlier) con parámetros α=${s.params[0]}, β=${s.params[1]}, κ=${s.params[2]}, Uth=${s.params[3]}, dr=${s.params[4]}, seed=${s.seed}`);
            }
          }
        }
      }
    }

    btnStart.disabled = false;
    btnStop.disabled = true;
  }

  btnStart.onclick = () => {
    if(isRunning) return;
    currentSimulationIndex = 0;
    runAllSimulations();
  };
  btnStop.onclick = () => {
    isRunning = false;
  };

  btnExport.onclick = () => {
    if(simulationData.length===0) return;
    let csv = 'alpha,beta,kappa,Uth,dr,seed,maxEnergy,focalDuration,jumps,entropy\n';
    for(const s of simulationData){
      csv += `${s.params[0]},${s.params[1]},${s.params[2]},${s.params[3]},${s.params[4]},${s.seed},${s.maxEnergy},${s.focalDuration},${s.jumps},${extractFeatures(s)[3].toFixed(5)}\n`;
    }
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `salto_espiral_ml_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Inicializar para dibujar vacío
  initArrays(cfg,1);
  drawSimulation();
})();
</script>
</body>
</html>
