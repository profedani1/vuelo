<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Protótipo Automático: Espiral Acoplada con Alertas</title>
<style>
  :root {
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#7dd3fc;
    --alert:#f87171;
    --muted:#94a3b8;
  }
  html,body {
    height:100%;
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Arial;
    background:var(--bg);
    color:#e6eef6;
  }
  .app {
    display:grid;
    grid-template-columns:420px 1fr;
    gap:18px;
    height:100vh;
    padding:18px;
  }
  .panel {
    background:linear-gradient(180deg,#071023 0%, #071229 60%);
    border-radius:12px;
    padding:14px;
    box-shadow:0 6px 18px rgba(2,6,23,.6);
    overflow:auto;
    display:flex;
    flex-direction: column;
  }
  h1 {
    font-size:18px;
    margin:0 0 8px;
  }
  label {
    display:block;
    margin-top:8px;
    font-size:13px;
    color:var(--muted);
  }
  .row {
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap: wrap;
  }
  input[type=range] {
    width:100%;
  }
  button {
    background:var(--accent);
    border:none;
    color:#042031;
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    user-select:none;
  }
  button:disabled {
    background:#374151;
    cursor: not-allowed;
  }
  .small {
    font-size:12px;
    color:var(--muted);
  }
  canvas {
    width:100%;
    height:100%;
    display:block;
    background:linear-gradient(180deg,#071226, #001525);
    border-radius:12px;
  }
  .stats {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin-top:8px;
  }
  .stat {
    background:#02111a;
    padding:8px;
    border-radius:8px;
    font-size:13px;
    min-width:120px;
  }
  #alertLog {
    margin-top:10px;
    background:#1a1f2d;
    border-radius:8px;
    padding:8px;
    height:120px;
    overflow-y: auto;
    font-family: monospace;
    font-size:12px;
    color:var(--alert);
    user-select: text;
  }
  footer {
    font-size:12px;
    color:var(--muted);
    margin-top:12px;
  }
  .flex-grow {
    flex-grow: 1;
  }
</style>
</head>
<body>
<div class="app">
  <div class="panel" style="max-height:calc(100vh - 36px);">
    <h1>Protótipo Automático: Espiral Acoplada con Alertas</h1>
    <div class="small">Este prototipo ejecuta simulaciones automáticas barriendo parámetros, detecta eventos interesantes y genera alertas para análisis científico.</div>

    <label>Parámetros fijos</label>
    <div class="row">
      <label style="flex-basis: 100%;">N nodos (resolución)</label>
      <input id="N" type="range" min="64" max="512" step="32" value="256" />
      <div id="Nval" class="small">256</div>
    </div>

    <label>Exploración automática</label>
    <div class="row" style="gap:6px; flex-wrap: nowrap;">
      <button id="btnStartAuto">Iniciar barrido automático</button>
      <button id="btnStopAuto" disabled>Detener</button>
      <button id="btnExportLogs" disabled>Exportar logs CSV</button>
    </div>

    <label>Configuración exploración</label>
    <div class="row" style="flex-wrap: wrap;">
      <label style="flex-basis: 50%;">Cantidad semillas</label>
      <input id="numSeeds" type="number" min="1" max="20" value="3" style="width: 80px" />
      <label style="flex-basis: 50%;">Sim steps por prueba</label>
      <input id="stepsPerSim" type="number" min="50" max="2000" value="500" style="width: 80px" />
    </div>

    <label>Rangos de parámetros para barrido</label>
    <div class="row" style="flex-wrap: wrap; gap:10px;">
      <label>α (perm.←mech)</label>
      <input id="alphaRange" type="text" value="0,0.5,1,1.5,2" style="flex-grow:1" />
      <label>β (perm.←|U|²)</label>
      <input id="betaRange" type="text" value="0,0.05,0.1,0.2" style="flex-grow:1" />
      <label>κ (tensión←U)</label>
      <input id="kappaRange" type="text" value="0,0.05,0.1,0.15" style="flex-grow:1" />
      <label>Umbral U_th</label>
      <input id="UthRange" type="text" value="0.05,0.08,0.12" style="flex-grow:1" />
      <label>Salto Δr</label>
      <input id="drRange" type="text" value="0.01,0.03,0.05" style="flex-grow:1" />
    </div>

    <label>Indicadores y alertas (configurables)</label>
    <div class="row" style="flex-wrap: wrap; gap:10px;">
      <label>Energía máxima local > </label>
      <input id="alertEnergyMax" type="number" min="0.01" max="10" step="0.01" value="0.15" style="width:80px" />
      <label>Duración mínima (steps) focalización</label>
      <input id="alertDuration" type="number" min="10" max="1000" value="100" style="width:80px" />
      <label>Saltos mínimos en sim</label>
      <input id="alertMinJumps" type="number" min="0" max="100" value="3" style="width:80px" />
    </div>

    <label>Estado actual de exploración</label>
    <div class="stats">
      <div class="stat">Pruebas totales: <span id="totalTests">0</span></div>
      <div class="stat">Prueba actual: <span id="currentTest">0</span></div>
      <div class="stat">Saltos detectados: <span id="totalJumps">0</span></div>
      <div class="stat">Alertas generadas: <span id="alertsCount">0</span></div>
    </div>

    <label>Registro de alertas</label>
    <pre id="alertLog" aria-live="polite"></pre>

    <footer>Prototipo avanzado para descubrir fenómenos físicos emergentes con simulaciones automáticas y alertas inteligentes.</footer>
  </div>

  <div class="panel flex-grow">
    <canvas id="cv"></canvas>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  let W=0,H=0;
  function resize(){
    W=cv.width=cv.clientWidth;
    H=cv.height=window.innerHeight-36;
  }
  window.addEventListener('resize',resize);
  resize();

  // UI elements
  const NSlider = document.getElementById('N');
  const Nval = document.getElementById('Nval');
  const btnStartAuto = document.getElementById('btnStartAuto');
  const btnStopAuto = document.getElementById('btnStopAuto');
  const btnExportLogs = document.getElementById('btnExportLogs');
  const alertLog = document.getElementById('alertLog');
  const currentTestElem = document.getElementById('currentTest');
  const totalTestsElem = document.getElementById('totalTests');
  const totalJumpsElem = document.getElementById('totalJumps');
  const alertsCountElem = document.getElementById('alertsCount');

  // Param inputs for sweep
  const numSeedsInput = document.getElementById('numSeeds');
  const stepsPerSimInput = document.getElementById('stepsPerSim');
  const alphaRangeInput = document.getElementById('alphaRange');
  const betaRangeInput = document.getElementById('betaRange');
  const kappaRangeInput = document.getElementById('kappaRange');
  const UthRangeInput = document.getElementById('UthRange');
  const drRangeInput = document.getElementById('drRange');

  // Alert thresholds
  const alertEnergyMaxInput = document.getElementById('alertEnergyMax');
  const alertDurationInput = document.getElementById('alertDuration');
  const alertMinJumpsInput = document.getElementById('alertMinJumps');

  let cfg = {
    N: parseInt(NSlider.value),
    dt: 0.002,
    alpha: 0.2,
    beta: 0.05,
    kappa: 0.12,
    gamma: 0.02,
    eta: 0.02,
    Uth: 0.08,
    dr: 0.03,
    a: 1,
    thetaTot: 16
  };

  NSlider.addEventListener('input', () => {
    cfg.N = parseInt(NSlider.value);
    Nval.textContent = NSlider.value;
  });

  // Simulation state and arrays
  let s, U, Uprev, u, uprev, v, r, theta;
  let jumps = 0;

  function initArrays() {
    const N = cfg.N;
    s = new Float64Array(N);
    U = new Float64Array(N);
    Uprev = new Float64Array(N);
    u = new Float64Array(N);
    uprev = new Float64Array(N);
    v = new Float64Array(N);
    r = new Float64Array(N);
    theta = new Float64Array(N);
    const ds = 1.0;
    for(let j=0; j<N; j++) {
      s[j] = j*ds;
      U[j] = 0; Uprev[j] = 0;
      u[j] = 0; uprev[j] = 0; v[j] = 0;
    }
    // geometry initial: r=a*theta with theta spacing
    for(let j=0; j<N; j++) {
      theta[j] = (j/(N-1))*cfg.thetaTot;
      r[j] = cfg.a*theta[j];
    }
    jumps = 0;
    totalJumpsElem.textContent = jumps;
  }

  initArrays();

  // Gradients and laplacian helpers
  function grad(arr,j){
    const N=arr.length;
    if(j<=0) return (arr[1]-arr[0]);
    if(j>=N-1) return (arr[N-1]-arr[N-2]);
    return (arr[j+1]-arr[j-1])/2;
  }

  function lap(arr,j){
    const N=arr.length;
    if(j<=0) return (arr[1]-2*arr[0]+arr[0]);
    if(j>=N-1) return (arr[N-1]-2*arr[N-2]+arr[N-1]);
    return (arr[j+1]-2*arr[j]+arr[j-1]);
  }

  // Step function for the coupled system
  function step(dt){
    const N = cfg.N;
    // compute eps_r and c
    const eps = new Float64Array(N);
    const c = new Float64Array(N);
    for(let j=0;j<N;j++) {
      const divu = grad(u,j);
      eps[j] = 1.0 + cfg.alpha*divu + cfg.beta*U[j]*U[j];
      c[j] = 1/Math.sqrt(eps[j]);
    }
    // compute new U using finite difference in time and space
    const newU = new Float64Array(N);
    for(let j=1;j<N-1;j++) {
      const lapU = lap(U,j);
      const divc = (c[j+1]-c[j-1])/2;
      const dUd = (U[j] - Uprev[j])/dt;
      newU[j] =
        2*U[j] - Uprev[j] +
        dt*dt*( c[j]*c[j]*lapU - 2*cfg.gamma*dUd )
        - dt*dt*cfg.kappa*U[j];
    }
    // boundary fixed zero
    newU[0] = 0;
    newU[N-1] = 0;

    // detect jumps
    for(let j=1;j<N-1;j++) {
      if(Math.abs(newU[j]-U[j]) > cfg.Uth) {
        jumps++;
      }
    }
    totalJumpsElem.textContent = jumps;

    // update states
    for(let j=0;j<N;j++) {
      Uprev[j] = U[j];
      U[j] = newU[j];
    }

    // simple damping on u
    for(let j=1;j<N-1;j++) {
      const lapu = lap(u,j);
      const T = U[j]*U[j];
      const sigma = 0.1;
      const dtt_u = lapu + T;
      uprev[j] = u[j];
      u[j] += dt*dt*dtt_u - dt*cfg.eta*u[j];
    }
  }

  // Visualization
  function draw(){
    ctx.clearRect(0,0,W,H);
    const N = cfg.N;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'cyan';
    ctx.beginPath();
    for(let j=0;j<N;j++) {
      const angle = theta[j];
      const rad = r[j] + 20*U[j];
      const x = W/2 + rad*Math.cos(angle);
      const y = H/2 + rad*Math.sin(angle);
      if(j===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Draw jumps as red points
    ctx.fillStyle = 'red';
    for(let j=1;j<N-1;j++) {
      if(Math.abs(U[j]-Uprev[j]) > cfg.Uth) {
        const angle = theta[j];
        const rad = r[j] + 20*U[j];
        const x = W/2 + rad*Math.cos(angle);
        const y = H/2 + rad*Math.sin(angle);
        ctx.beginPath();
        ctx.arc(x,y,3,0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  // ==== Exploración automática ====

  // Util para parsear rangos: "0,0.1,0.2" => [0,0.1,0.2]
  function parseRange(str) {
    return str.split(',').map(x=>parseFloat(x.trim())).filter(x=>!isNaN(x));
  }

  // Generar todas las combinaciones de parámetros
  function cartesian(arrays) {
    if(arrays.length===0) return [[]];
    const rest = cartesian(arrays.slice(1));
    const result = [];
    for(const v of arrays[0]) {
      for(const r of rest) {
        result.push([v,...r]);
      }
    }
    return result;
  }

  let isRunning = false;
  let testQueue = [];
  let testIndex = 0;
  let totalTestsCount = 0;

  // Logs y alertas
  let alertCount = 0;
  let totalJumpsCount = 0;
  let logs = [];

  function logAlert(text){
    alertCount++;
    alertsCountElem.textContent = alertCount;
    const time = new Date().toLocaleTimeString();
    alertLog.textContent = `${time} - ${text}\n` + alertLog.textContent;
  }

  function resetStats(){
    testIndex = 0;
    totalTestsCount = 0;
    alertCount = 0;
    logs = [];
    totalJumpsCount = 0;
    alertsCountElem.textContent = '0';
    totalJumpsElem.textContent = '0';
    alertLog.textContent = '';
    currentTestElem.textContent = '0';
    totalTestsElem.textContent = '0';
  }

  async function runTest(params, seed) {
    cfg.alpha = params[0];
    cfg.beta = params[1];
    cfg.kappa = params[2];
    cfg.Uth = params[3];
    cfg.dr = params[4];

    initArrays();

    // Seed the initial U with small random noise
    for(let j=0;j<cfg.N;j++){
      U[j] = (Math.random()-0.5)*0.02*seed;
      Uprev[j] = U[j];
    }

    let maxEnergy = 0;
    let jumpCount = 0;
    let focalDuration = 0;

    for(let stepi=0; stepi < parseInt(stepsPerSimInput.value); stepi++) {
      step(cfg.dt);

      // Energy local máxima
      const energyLocal = Math.max(...U.map(x=>Math.abs(x)));

      if(energyLocal > maxEnergy) maxEnergy = energyLocal;

      // Detección salto focal (energía local sobre umbral)
      if(energyLocal > cfg.Uth) {
        focalDuration++;
      } else if(focalDuration>0){
        focalDuration=0;
      }

      // Contar saltos
      for(let j=1;j<cfg.N-1;j++){
        if(Math.abs(U[j]-Uprev[j]) > cfg.Uth){
          jumpCount++;
          totalJumpsCount++;
        }
      }

      // Pequeña pausa para no bloquear UI
      if(stepi%200===0) await new Promise(r=>setTimeout(r,0));
    }

    // Guardar logs
    logs.push({
      alpha: cfg.alpha,
      beta: cfg.beta,
      kappa: cfg.kappa,
      Uth: cfg.Uth,
      dr: cfg.dr,
      maxEnergy,
      focalDuration,
      jumpCount,
      seed,
    });

    totalJumpsElem.textContent = totalJumpsCount;

    // Reglas alertas
    const energyThresh = parseFloat(alertEnergyMaxInput.value);
    const durThresh = parseInt(alertDurationInput.value);
    const jumpThresh = parseInt(alertMinJumpsInput.value);

    if(maxEnergy > energyThresh && focalDuration >= durThresh && jumpCount >= jumpThresh) {
      logAlert(`Alerta: Parámetros α=${cfg.alpha} β=${cfg.beta} κ=${cfg.kappa} Uth=${cfg.Uth} dr=${cfg.dr} → maxEnergy=${maxEnergy.toFixed(3)}, dur=${focalDuration}, jumps=${jumpCount}, seed=${seed}`);
    }
  }

  async function runAllTests() {
    resetStats();

    // Parse param ranges
    const alphas = parseRange(alphaRangeInput.value);
    const betas = parseRange(betaRangeInput.value);
    const kappas = parseRange(kappaRangeInput.value);
    const Uths = parseRange(UthRangeInput.value);
    const drs = parseRange(drRangeInput.value);
    const seedsCount = parseInt(numSeedsInput.value);

    // Generate param combos cartesian product
    const combos = cartesian([alphas, betas, kappas, Uths, drs]);
    totalTestsCount = combos.length * seedsCount;
    totalTestsElem.textContent = totalTestsCount;

    isRunning = true;
    btnStartAuto.disabled = true;
    btnStopAuto.disabled = false;
    btnExportLogs.disabled = true;

    for(let i=0; i<combos.length && isRunning; i++) {
      for(let seed=1; seed<=seedsCount && isRunning; seed++) {
        currentTestElem.textContent = i*seedsCount + seed;
        await runTest(combos[i], seed);
      }
    }

    btnStartAuto.disabled = false;
    btnStopAuto.disabled = true;
    btnExportLogs.disabled = false;
    isRunning = false;
  }

  btnStartAuto.onclick = () => {
    if(isRunning) return;
    runAllTests();
  };

  btnStopAuto.onclick = () => {
    isRunning = false;
  };

  btnExportLogs.onclick = () => {
    if(logs.length===0) return;
    let csv = "alpha,beta,kappa,Uth,dr,maxEnergy,focalDuration,jumpCount,seed\n";
    logs.forEach(l => {
      csv += `${l.alpha},${l.beta},${l.kappa},${l.Uth},${l.dr},${l.maxEnergy},${l.focalDuration},${l.jumpCount},${l.seed}\n`;
    });
    const blob = new Blob([csv], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `salto_espiral_alertas_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Main loop solo para visualización mientras corren simulaciones
  function animate(){
    draw();
    requestAnimationFrame(animate);
  }
  animate();
})();
</script>
</body>
</html>
