<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Terreno 3D con Volcán y Partículas (WebGL puro)</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #000a12;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #eee;
    font-family: monospace;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #00111f;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script type="module">

const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2');

if (!gl) {
  alert('WebGL 2 no soportado en este navegador');
  throw 'No WebGL2';
}
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);

// --- SHADERS ---

// Vertex shader para terreno
const terrainVS = `#version 300 es
precision highp float;

in vec3 aPosition;
in vec2 aUV;

uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;

out vec2 vUV;
out vec3 vNormal;
out vec3 vPositionWorld;

// Simple hash para ruido 2D
float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}
// Ruido interpolado (value noise)
float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

void main() {
  // Altura con ruido: escala 5 vueltas, amplitud 0.2
  float height = noise(aUV * 5.0) * 0.2;

  // Posición final con altura
  vec3 pos = aPosition + vec3(0.0, height, 0.0);

  // Normales aproximadas calculadas por diferencias
  float hL = noise((aUV + vec2(-0.01, 0.0))*5.0)*0.2;
  float hR = noise((aUV + vec2(0.01, 0.0))*5.0)*0.2;
  float hD = noise((aUV + vec2(0.0, -0.01))*5.0)*0.2;
  float hU = noise((aUV + vec2(0.0, 0.01))*5.0)*0.2;

  vec3 normal = normalize(vec3(hL - hR, 2.0, hD - hU));

  vNormal = normal;
  vUV = aUV;
  vPositionWorld = (uModel * vec4(pos, 1.0)).xyz;

  gl_Position = uProjection * uView * uModel * vec4(pos, 1.0);
}
`;

// Fragment shader para terreno
const terrainFS = `#version 300 es
precision highp float;

in vec2 vUV;
in vec3 vNormal;
in vec3 vPositionWorld;

uniform vec3 uCameraPos;

out vec4 outColor;

void main() {
  vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
  float diff = max(dot(normalize(vNormal), lightDir), 0.0);

  // Color base mezclado con verde según vUV.y (altura)
  vec3 baseColor = mix(vec3(0.0,0.2,0.0), vec3(0.6,0.8,0.4), vUV.y);

  // Pico volcánico central rojo-anaranjado brillante
  float dist = distance(vUV, vec2(0.5, 0.5));
  if(dist < 0.1) {
    baseColor += vec3(1.5,0.4,0.1) * (0.1 - dist) * 10.0;
  }

  vec3 color = baseColor * diff;

  // Niebla azulada según distancia cámara-terreno
  float distCam = length(uCameraPos - vPositionWorld);
  float fogAmount = smoothstep(3.0, 10.0, distCam);
  vec3 fogColor = vec3(0.1,0.15,0.2);
  color = mix(color, fogColor, fogAmount);

  outColor = vec4(color, 1.0);
}
`;

// Vertex shader para partículas
const particleVS = `#version 300 es
precision highp float;

in vec3 aPosition;
in float aPointSize;

uniform mat4 uProjection;
uniform mat4 uView;

void main() {
  gl_Position = uProjection * uView * vec4(aPosition, 1.0);
  gl_PointSize = aPointSize;
}
`;

// Fragment shader para partículas
const particleFS = `#version 300 es
precision highp float;

out vec4 outColor;

void main() {
  // Gradiente circular para que el punto parezca una partícula
  vec2 coord = gl_PointCoord - vec2(0.5);
  float dist = length(coord);
  float alpha = smoothstep(0.5, 0.0, dist);

  vec3 color = vec3(1.0, 0.5, 0.0) * alpha; // naranja
  outColor = vec4(color, alpha);
}
`;

// --- FUNCIONES DE UTILIDAD ---

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Error compilando shader:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Error linkeando programa:', gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

// Matrices básicas (sin librerías externas)
function createPerspectiveMatrix(fov, aspect, near, far) {
  const f = 1 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  const out = new Float32Array(16);
  out[0] = f / aspect;
  out[5] = f;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[14] = (2 * far * near) * nf;
  return out;
}
function createLookAtMatrix(eye, center, up) {
  const f = normalize(subtractVectors(center, eye));
  const s = normalize(cross(f, up));
  const u = cross(s, f);

  const out = new Float32Array(16);
  out[0] = s[0];
  out[1] = u[0];
  out[2] = -f[0];
  out[3] = 0;

  out[4] = s[1];
  out[5] = u[1];
  out[6] = -f[1];
  out[7] = 0;

  out[8] = s[2];
  out[9] = u[2];
  out[10] = -f[2];
  out[11] = 0;

  out[12] = -dot(s, eye);
  out[13] = -dot(u, eye);
  out[14] = dot(f, eye);
  out[15] = 1;

  return out;
}
function multiplyMatrices(a,b) {
  const out = new Float32Array(16);
  for(let i=0;i<4;++i) {
    for(let j=0;j<4;++j) {
      out[i*4+j] = 0.0;
      for(let k=0;k<4;++k) {
        out[i*4+j] += a[i*4+k]*b[k*4+j];
      }
    }
  }
  return out;
}
function normalize(v) {
  const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  return [v[0]/len, v[1]/len, v[2]/len];
}
function subtractVectors(a,b) {
  return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
}
function cross(a,b) {
  return [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
}
function dot(a,b) {
  return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

// --- CREAR GEOMETRÍA ---

// Creamos un grid plano subdividido NxN (usaremos N=50)
function createGrid(size) {
  const positions = [];
  const uvs = [];
  const indices = [];

  const step = 1 / size;
  for(let y=0; y<=size; y++) {
    for(let x=0; x<=size; x++) {
      // Posición XY en plano [-0.5..0.5]
      positions.push(x*step - 0.5, 0, y*step - 0.5);
      uvs.push(x*step, y*step);
    }
  }
  // Triangulación en grid
  for(let y=0; y<size; y++) {
    for(let x=0; x<size; x++) {
      const i = y*(size+1) + x;
      indices.push(i, i+1, i+size+1);
      indices.push(i+1, i+size+2, i+size+1);
    }
  }

  return {
    positions: new Float32Array(positions),
    uvs: new Float32Array(uvs),
    indices: new Uint16Array(indices)
  };
}

// --- INICIALIZAR TERRRENO ---

const terrainProgram = createProgram(gl, terrainVS, terrainFS);
const terrainPosLoc = gl.getAttribLocation(terrainProgram, 'aPosition');
const terrainUVLoc = gl.getAttribLocation(terrainProgram, 'aUV');

const uProjectionLoc = gl.getUniformLocation(terrainProgram, 'uProjection');
const uViewLoc = gl.getUniformLocation(terrainProgram, 'uView');
const uModelLoc = gl.getUniformLocation(terrainProgram, 'uModel');
const uCameraPosLoc = gl.getUniformLocation(terrainProgram, 'uCameraPos');

const grid = createGrid(50);

// Buffers terreno
const terrainVAO = gl.createVertexArray();
gl.bindVertexArray(terrainVAO);

const terrainPosBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, terrainPosBuffer);
gl.bufferData(gl.ARRAY_BUFFER, grid.positions, gl.STATIC_DRAW);
gl.enableVertexAttribArray(terrainPosLoc);
gl.vertexAttribPointer(terrainPosLoc, 3, gl.FLOAT, false, 0, 0);

const terrainUVBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, terrainUVBuffer);
gl.bufferData(gl.ARRAY_BUFFER, grid.uvs, gl.STATIC_DRAW);
gl.enableVertexAttribArray(terrainUVLoc);
gl.vertexAttribPointer(terrainUVLoc, 2, gl.FLOAT, false, 0, 0);

const terrainIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIndexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, grid.indices, gl.STATIC_DRAW);

gl.bindVertexArray(null);

// --- PARTICULAS VOLCANICAS ---

const particleProgram = createProgram(gl, particleVS, particleFS);
const particlePosLoc = gl.getAttribLocation(particleProgram, 'aPosition');
const particlePointSizeLoc = gl.getAttribLocation(particleProgram, 'aPointSize');

const particleCount = 200;
const particlePositions = new Float32Array(particleCount * 3);
const particleSizes = new Float32Array(particleCount);

// Inicializar partículas en la base volcán (cerca centro en XY y altura cerca 0.2)
for(let i=0; i<particleCount; i++) {
  // X,Z dispersos cerca de centro (0,0)
  particlePositions[i*3+0] = (Math.random()-0.5)*0.1;
  particlePositions[i*3+1] = 0.2 + Math.random()*0.1; // altura inicial
  particlePositions[i*3+2] = (Math.random()-0.5)*0.1;
  particleSizes[i] = 10 + Math.random()*5;
}

// Buffers partículas
const particleVAO = gl.createVertexArray();
gl.bindVertexArray(particleVAO);

const particlePosBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, particlePosBuffer);
gl.bufferData(gl.ARRAY_BUFFER, particlePositions, gl.DYNAMIC_DRAW);
gl.enableVertexAttribArray(particlePosLoc);
gl.vertexAttribPointer(particlePosLoc, 3, gl.FLOAT, false, 0, 0);

const particleSizeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, particleSizeBuffer);
gl.bufferData(gl.ARRAY_BUFFER, particleSizes, gl.STATIC_DRAW);
gl.enableVertexAttribArray(particlePointSizeLoc);
gl.vertexAttribPointer(particlePointSizeLoc, 1, gl.FLOAT, false, 0, 0);

gl.bindVertexArray(null);

// --- MATRICES Y CÁMARA ---

let cameraPos = [0, 1.2, 1.8];
let cameraTarget = [0, 0, 0];
let upVector = [0, 1, 0];

const fov = Math.PI / 4;
const aspect = canvas.width / canvas.height;
const near = 0.1;
const far = 100;

const projMatrix = createPerspectiveMatrix(fov, aspect, near, far);

// Modelo identidad para terreno
const modelMatrix = new Float32Array(16);
for(let i=0;i<16;++i) modelMatrix[i] = (i%5 === 0) ? 1 : 0; // identity

// --- ANIMACIÓN ---

// Variables partículas
const particleVelocities = new Float32Array(particleCount * 3);
for(let i=0; i<particleCount; i++) {
  // Velocidad inicial hacia arriba y dispersión lateral
  particleVelocities[i*3+0] = (Math.random()-0.5)*0.002;
  particleVelocities[i*3+1] = 0.005 + Math.random()*0.003;
  particleVelocities[i*3+2] = (Math.random()-0.5)*0.002;
}

function updateParticles() {
  for(let i=0; i<particleCount; i++) {
    let idx = i*3;
    // Actualizamos posición
    particlePositions[idx+0] += particleVelocities[idx+0];
    particlePositions[idx+1] += particleVelocities[idx+1];
    particlePositions[idx+2] += particleVelocities[idx+2];

    // Si la partícula sube demasiado o se dispersa mucho, la reseteamos a base
    if(particlePositions[idx+1] > 1.2 || Math.abs(particlePositions[idx+0]) > 0.5 || Math.abs(particlePositions[idx+2]) > 0.5) {
      particlePositions[idx+0] = (Math.random()-0.5)*0.1;
      particlePositions[idx+1] = 0.2 + Math.random()*0.1;
      particlePositions[idx+2] = (Math.random()-0.5)*0.1;
    }
  }
}

// --- RENDER ---

function render(time=0) {
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0.0, 0.05, 0.1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  // Cámara con ligera órbita horizontal
  const angle = time * 0.0002;
  cameraPos = [Math.sin(angle)*2, 1.2, Math.cos(angle)*2];
  const viewMatrix = createLookAtMatrix(cameraPos, cameraTarget, upVector);

  // --- Dibujar terreno ---
  gl.useProgram(terrainProgram);
  gl.bindVertexArray(terrainVAO);
  gl.uniformMatrix4fv(uProjectionLoc, false, projMatrix);
  gl.uniformMatrix4fv(uViewLoc, false, viewMatrix);
  gl.uniformMatrix4fv(uModelLoc, false, modelMatrix);
  gl.uniform3fv(uCameraPosLoc, cameraPos);
  gl.drawElements(gl.TRIANGLES, grid.indices.length, gl.UNSIGNED_SHORT, 0);

  // --- Actualizar y dibujar partículas ---
  updateParticles();

  gl.useProgram(particleProgram);
  gl.bindVertexArray(particleVAO);

  // Actualizar buffer posiciones partículas
  gl.bindBuffer(gl.ARRAY_BUFFER, particlePosBuffer);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, particlePositions);

  gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, projMatrix);
  gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'uView'), false, viewMatrix);

  gl.drawArrays(gl.POINTS, 0, particleCount);

  gl.bindVertexArray(null);

  requestAnimationFrame(render);
}

requestAnimationFrame(render);

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
});

</script>
</body>
</html>
