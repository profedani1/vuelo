<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Esfera adaptada a la imagen (captura de forma)</title>
<style>
  :root { --aside-w: 38vw; --bg:#0b0b0b; --panel:#141414; --fg:#eaeaea; --muted:#333; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Arial,sans-serif;height:100vh;display:flex}
  #left{width:var(--aside-w);min-width:300px;border-right:1px solid var(--muted);display:flex;flex-direction:column}
  #right{flex:1;position:relative;display:flex;flex-direction:column}
  #videoWrap{position:relative;aspect-ratio:16/9;background:#000}
  #video{width:100%;height:100%;object-fit:cover}
  #controls{padding:10px;background:var(--panel);display:grid;grid-template-columns:1fr 1fr;gap:8px;border-top:1px solid var(--muted)}
  #controls button, #controls select, #controls input[type=checkbox]+label { font-size:14px }
  #controls button{cursor:pointer;padding:8px;border:1px solid #222;background:#1f1f1f;color:#fff;border-radius:8px}
  #controls button:active{transform:scale(0.98)}
  #renderer{flex:1;min-height:0}
  canvas{display:block;width:100%;height:100%}
  #status{position:absolute;left:10px;bottom:10px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:8px;font-size:12px;color:#ddd}
  .row{grid-column:1/-1;display:flex;gap:10px;align-items:center}
  .spacer{height:8px;grid-column:1/-1}
  .toggle{display:flex;align-items:center;gap:6px}
  @media (max-width: 1100px){
    body{flex-direction:column}
    #left{width:100%;min-width:auto}
    #right{height:60vh}
  }
</style>
</head>
<body>
  <aside id="left">
    <div id="videoWrap">
      <video id="video" autoplay playsinline muted></video>
    </div>
    <div id="controls">
      <button id="btnStart">Iniciar cámara</button>
      <button id="btnStop">Detener cámara</button>

      <button id="btnFreeze">Capturar forma</button>
      <button id="btnLive">Volver a vivo</button>

      <button id="btnShot" class="row">Captura de pantalla</button>
      <button id="btnExport" class="row">Exportar GLB (capturado)</button>

      <div class="row">
        <div class="toggle">
          <input type="checkbox" id="chkFlat" />
          <label for="chkFlat">Flat Shading</label>
        </div>
        <div class="toggle">
          <input type="checkbox" id="chkWire" />
          <label for="chkWire">Wireframe</label>
        </div>
      </div>

      <div class="row">
        <label style="min-width:120px">Frecuencia base:</label>
        <input id="freqBase" type="range" min="0" max="10" value="2" step="0.1" style="flex:1" />
      </div>
      <div class="row">
        <label style="min-width:120px">Amplitud máx.:</label>
        <input id="ampMax" type="range" min="0" max="1.5" value="0.6" step="0.01" style="flex:1" />
      </div>
      <div class="row">
        <label style="min-width:120px">Velocidad:</label>
        <input id="speed" type="range" min="0" max="3" value="1" step="0.01" style="flex:1" />
      </div>
      <div class="row">
        <label style="min-width:120px">Segmentos:</label>
        <input id="seg" type="range" min="16" max="256" value="96" step="1" style="flex:1" />
      </div>

      <div class="spacer"></div>

      <div class="row">
        <label style="min-width:120px">Radio X:</label>
        <input id="radiusX" type="range" min="0.2" max="4" value="1.4" step="0.01" style="flex:1" />
      </div>
      <div class="row">
        <label style="min-width:120px">Radio Y:</label>
        <input id="radiusY" type="range" min="0.2" max="4" value="1.0" step="0.01" style="flex:1" />
      </div>
      <div class="row">
        <label style="min-width:120px">Radio Z:</label>
        <input id="radiusZ" type="range" min="0.2" max="4" value="1.4" step="0.01" style="flex:1" />
      </div>
    </div>
  </aside>

  <main id="right">
    <div id="renderer"></div>
    <div id="status">estado: listo</div>
  </main>

  <!-- three.js + orbit controls + gltf exporter -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/exporters/GLTFExporter.js"></script>

  <script>
  (() => {
    const status = document.getElementById('status');
    const setStatus = (s) => status.textContent = 'estado: ' + s;

    // --- cámara (video + canvas oculto) ---
    const video = document.getElementById('video');
    const hidden = document.createElement('canvas');
    const hctx = hidden.getContext('2d', { willReadFrequently: true });
    let stream = null;

    async function startCam(){
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
        video.srcObject = stream;
        setStatus('cámara iniciada');
      } catch (e) {
        console.error(e);
        setStatus('error al iniciar cámara');
      }
    }
    function stopCam(){
      if (stream) stream.getTracks().forEach(t=>t.stop());
      stream = null;
      setStatus('cámara detenida');
    }

    // --- escena three ---
    const rendererEl = document.getElementById('renderer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);
    const camera = new THREE.PerspectiveCamera(60, rendererEl.clientWidth/rendererEl.clientHeight, 0.1, 100);
    camera.position.set(0,0,5);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(rendererEl.clientWidth, rendererEl.clientHeight);
    rendererEl.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const ambient = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(3,3,5);
    scene.add(dir);

    // parámetros
    const params = {
      seg: 96,
      baseFreq: 2.0,
      ampMax: 0.6,
      speed: 1.0,
      radiusX: 1.4,
      radiusY: 1.0,
      radiusZ: 1.4,
      wireframe: false,
      flat: false
    };

    // geometría viva y capturada
    let liveMesh, capturedMesh = null;
    let originalPositions, originalNormals;
    let imageData = null;
    let showCaptured = false; // si true, se muestra el modelo capturado (congelado)

    function makeMaterial(){
      return new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.5,
        metalness: 0.1,
        flatShading: params.flat,
        wireframe: params.wireframe,
        side: THREE.DoubleSide
      });
    }

    function buildLiveMesh(){
      if (liveMesh){
        scene.remove(liveMesh);
        liveMesh.geometry.dispose();
        liveMesh.material.dispose();
      }
      const geo = new THREE.SphereGeometry(1, params.seg, params.seg);
      geo.scale(params.radiusX, params.radiusY, params.radiusZ);

      // guardo copias de posiciones/normales originales
      originalPositions = geo.attributes.position.array.slice();
      originalNormals = geo.attributes.normal.array.slice();

      liveMesh = new THREE.Mesh(geo, makeMaterial());
      scene.add(liveMesh);
    }

    // util rgb->hsl
    function rgbToHsl(r,g,b){
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      let h, s, l = (max + min)/2;
      if (max === min){ h = s = 0; }
      else {
        const d = max - min;
        s = l > 0.5 ? d/(2 - max - min) : d/(max + min);
        switch (max){
          case r: h = (g - b)/d + (g < b ? 6 : 0); break;
          case g: h = (b - r)/d + 2; break;
          case b: h = (r - g)/d + 4; break;
        }
        h /= 6;
      }
      return { h, s, l };
    }

    // deformación en vivo
    let t = 0;
    function updateLiveDeform(dt){
      if (!liveMesh || showCaptured) return;
      const geo = liveMesh.geometry;
      const pos = geo.attributes.position.array;
      const norm = geo.attributes.normal.array;

      // preparar lectura de cámara
      if (video.readyState >= 2 && stream){
        if (hidden.width !== video.videoWidth || hidden.height !== video.videoHeight){
          hidden.width = video.videoWidth;
          hidden.height = video.videoHeight;
        }
        hctx.drawImage(video, 0, 0, hidden.width, hidden.height);
        imageData = hctx.getImageData(0,0,hidden.width, hidden.height).data;
      } else {
        imageData = null; // si no hay cámara, no deformamos
      }

      for (let i = 0; i < pos.length; i += 3){
        const ix = i;
        const iy = i + 1;
        const iz = i + 2;

        const ox = originalPositions[ix];
        const oy = originalPositions[iy];
        const oz = originalPositions[iz];

        const nx = originalNormals[ix];
        const ny = originalNormals[iy];
        const nz = originalNormals[iz];

        // UV aproximado sobre esfera
        const r = Math.sqrt(ox*ox + oy*oy + oz*oz) || 1e-6;
        const u = 0.5 + Math.atan2(oz, ox)/(2*Math.PI);
        const v = 0.5 - Math.asin(oy/r)/Math.PI;

        let hue = 0.0, sat = 0.0, lum = 0.0;
        if (imageData){
          const px = Math.min(hidden.width - 1, Math.max(0, Math.floor(u*hidden.width)));
          const py = Math.min(hidden.height - 1, Math.max(0, Math.floor(v*hidden.height)));
          const idx = (py*hidden.width + px)*4;
          const rr = imageData[idx]/255;
          const gg = imageData[idx+1]/255;
          const bb = imageData[idx+2]/255;
          const hsl = rgbToHsl(rr,gg,bb);
          hue = hsl.h; sat = hsl.s; lum = hsl.l;
        }

        // mapear color -> parámetros
        const freqTheta = params.baseFreq + hue*10.0;
        const freqPhi   = params.baseFreq + sat*10.0;
        const amp       = 0.05 + lum*params.ampMax; // luminancia controla amplitud

        // ángulos esféricos (sobre la malla escalada)
        const theta = Math.acos(THREE.MathUtils.clamp(oy / (r || 1), -1, 1)); // 0..PI
        const phi = Math.atan2(oz, ox); // -PI..PI

        const disp = amp * Math.sin(freqTheta*theta + freqPhi*phi + t);

        pos[ix] = ox + nx * disp;
        pos[iy] = oy + ny * disp;
        pos[iz] = oz + nz * disp;
      }

      geo.attributes.position.needsUpdate = true;
      geo.computeVertexNormals();
      t += dt * params.speed;
    }

    // captura de forma (congela la geometría actual)
    function captureShape(){
      if (!liveMesh) return;

      // clonar geometría deformada actual
      const capturedGeo = liveMesh.geometry.clone();
      // por seguridad, hacer deep clone de atributos
      const pos = capturedGeo.attributes.position;
      capturedGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pos.array), 3));
      capturedGeo.computeVertexNormals();

      if (capturedMesh){
        scene.remove(capturedMesh);
        capturedMesh.geometry.dispose();
        capturedMesh.material.dispose();
      }
      capturedMesh = new THREE.Mesh(capturedGeo, makeMaterial());
      capturedMesh.material.color.set(0x9ad1ff);
      scene.add(capturedMesh);

      showCaptured = true; // mostrar capturado
      setStatus('forma capturada (modelo congelado)');
    }

    function returnToLive(){
      showCaptured = false;
      setStatus('vivo (deformación por cámara)');
    }

    // capturar pantalla del render
    function screenshot(){
      const link = document.createElement('a');
      link.download = 'captura_esfera.png';
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    }

    // exportar GLB del modelo capturado
    function exportGLB(){
      if (!capturedMesh){
        setStatus('no hay modelo capturado');
        return;
      }
      const exporter = new THREE.GLTFExporter();
      exporter.parse(capturedMesh, (gltf) => {
        const blob = new Blob([gltf instanceof ArrayBuffer ? gltf : JSON.stringify(gltf)], { type: 'model/gltf-binary' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'modelo_capturado.glb';
        a.click();
        URL.revokeObjectURL(a.href);
      }, { binary: true });
      setStatus('exportado GLB');
    }

    // listeners UI
    document.getElementById('btnStart').addEventListener('click', startCam);
    document.getElementById('btnStop').addEventListener('click', stopCam);
    document.getElementById('btnFreeze').addEventListener('click', captureShape);
    document.getElementById('btnLive').addEventListener('click', returnToLive);
    document.getElementById('btnShot').addEventListener('click', screenshot);
    document.getElementById('btnExport').addEventListener('click', exportGLB);

    document.getElementById('chkFlat').addEventListener('input', (e)=>{
      params.flat = e.target.checked;
      if (liveMesh){ liveMesh.material.flatShading = params.flat; liveMesh.material.needsUpdate = true; }
      if (capturedMesh){ capturedMesh.material.flatShading = params.flat; capturedMesh.material.needsUpdate = true; }
    });
    document.getElementById('chkWire').addEventListener('input', (e)=>{
      params.wireframe = e.target.checked;
      if (liveMesh) liveMesh.material.wireframe = params.wireframe;
      if (capturedMesh) capturedMesh.material.wireframe = params.wireframe;
    });

    const segEl = document.getElementById('seg');
    const baseEl = document.getElementById('freqBase');
    const ampEl = document.getElementById('ampMax');
    const spdEl = document.getElementById('speed');
    const rxEl = document.getElementById('radiusX');
    const ryEl = document.getElementById('radiusY');
    const rzEl = document.getElementById('radiusZ');

    segEl.addEventListener('input', ()=>{ params.seg = +segEl.value; buildLiveMesh(); setStatus('segmentos: '+params.seg) });
    baseEl.addEventListener('input', ()=>{ params.baseFreq = +baseEl.value; });
    ampEl.addEventListener('input', ()=>{ params.ampMax = +ampEl.value; });
    spdEl.addEventListener('input', ()=>{ params.speed = +spdEl.value; });

    function rebuildScaled(){
      if (!liveMesh) return;
      const geo = new THREE.SphereGeometry(1, params.seg, params.seg);
      geo.scale(params.radiusX, params.radiusY, params.radiusZ);
      // volver a setear originales
      originalPositions = geo.attributes.position.array.slice();
      originalNormals = geo.attributes.normal.array.slice();
      liveMesh.geometry.dispose();
      liveMesh.geometry = geo;
      setStatus(`radio XYZ: ${params.radiusX.toFixed(2)} ${params.radiusY.toFixed(2)} ${params.radiusZ.toFixed(2)}`);
    }
    rxEl.addEventListener('input', ()=>{ params.radiusX = +rxEl.value; rebuildScaled(); });
    ryEl.addEventListener('input', ()=>{ params.radiusY = +ryEl.value; rebuildScaled(); });
    rzEl.addEventListener('input', ()=>{ params.radiusZ = +rzEl.value; rebuildScaled(); });

    // init
    buildLiveMesh();
    setStatus('listo: inicia la cámara y deforma en vivo; captura para congelar');

    // resize
    function onResize(){
      renderer.setSize(rendererEl.clientWidth, rendererEl.clientHeight);
      camera.aspect = rendererEl.clientWidth/rendererEl.clientHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // loop
    let last = performance.now();
    function tick(now){
      requestAnimationFrame(tick);
      const dt = Math.min(0.05, (now - last)/1000); // clamp dt
      last = now;

      controls.update();

      if (showCaptured){
        // mostrar solo capturado
        if (liveMesh) liveMesh.visible = false;
        if (capturedMesh) capturedMesh.visible = true;
      } else {
        if (liveMesh) liveMesh.visible = true;
        if (capturedMesh) capturedMesh.visible = !!capturedMesh; // puede coexistir, pero oculto si quieres
        updateLiveDeform(dt);
      }

      renderer.render(scene, camera);
    }
    tick(last);
  })();
  </script>
</body>
</html>
