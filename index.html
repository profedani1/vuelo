<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulación + Detección Automática de Descubrimientos Científicos</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin:0; background:#0a1226; color:#cfd9e9;
    display: flex; flex-direction: column; height: 100vh;
  }
  header {
    background:#061126; padding: 0.5rem 1rem; font-weight: bold; font-size: 1.2rem;
  }
  main {
    display:flex; flex:1; overflow:hidden;
  }
  #leftPanel {
    width:350px; background:#0d1839; padding:1rem; overflow-y:auto;
    box-shadow: inset -3px 0 6px #021026;
  }
  #rightPanel {
    flex:1; display:flex; flex-direction: column;
  }
  #canvasContainer {
    flex:1; background:#07152f;
    display:flex; justify-content:center; align-items:center;
  }
  canvas {
    background:#0a1a3c; border-radius:12px;
    max-width: 100%; max-height: 100%;
  }
  button {
    background:#2a62bf; border:none; color:#dde6f5;
    padding:0.5rem 1rem; margin-top:1rem;
    cursor:pointer; border-radius:8px;
  }
  button:disabled {
    background:#4c7dc9aa;
    cursor: not-allowed;
  }
  h2 {
    margin-top: 0;
  }
  .alert {
    background:#f45c5c; padding:0.5rem; border-radius:6px; margin-top:0.5rem; font-weight: bold;
    color:#fff;
  }
  .log {
    background:#07172f; border-radius:8px; padding:8px; height: 180px; overflow-y: auto; font-family: monospace; font-size: 12px;
    margin-top: 0.5rem;
  }
  .stat {
    margin-top: 0.4rem;
  }
  #clustersPlot {
    margin-top: 1rem;
    height: 180px;
    background: #0b1b3a;
    border-radius: 10px;
    padding: 6px;
    font-size: 12px;
    overflow-x: auto;
    white-space: nowrap;
  }
</style>
</head>
<body>
<header>Simulación + Detección Automática de Descubrimientos Científicos</header>
<main>
  <section id="leftPanel">
    <h2>Controles</h2>
    <div>
      <button id="btnStart">Iniciar Exploración Automática</button>
      <button id="btnStop" disabled>Detener</button>
    </div>

    <h3>Estado</h3>
    <div class="stat">Simulaciones totales: <span id="totalSims">0</span></div>
    <div class="stat">Simulación actual: <span id="currentSim">0</span></div>
    <div class="stat">Alertas de descubrimiento: <span id="discAlertsCount">0</span></div>

    <h3>Alertas Detectadas</h3>
    <div id="alerts" class="log" aria-live="polite" aria-atomic="true"></div>

    <h3>Clusters y Análisis</h3>
    <div id="clustersPlot">(Gráfico de clusters aparecerá aquí)</div>
  </section>

  <section id="rightPanel">
    <div id="canvasContainer">
      <canvas id="canvas" width="600" height="600"></canvas>
    </div>
  </section>
</main>

<script>
(() => {
  // --- Parámetros y Configuración ---
  const paramGrid = {
    alpha: [0, 0.5, 1, 1.5, 2],
    beta: [0, 0.05, 0.1, 0.2],
    kappa: [0, 0.05, 0.1, 0.15],
    Uth: [0.05, 0.08, 0.12],
    dr: [0.01, 0.03, 0.05]
  };
  const seedsCount = 3;      // cantidad de seeds (variación aleatoria)
  const stepsPerSim = 500;   // pasos de simulación por corrida
  const N = 256;             // nodos de la simulación
  const evaluationInterval = 20; // simulaciones entre evaluaciones

  // Estado UI
  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const totalSimsSpan = document.getElementById('totalSims');
  const currentSimSpan = document.getElementById('currentSim');
  const discAlertsCountSpan = document.getElementById('discAlertsCount');
  const alertsDiv = document.getElementById('alerts');
  const clustersPlot = document.getElementById('clustersPlot');

  // Canvas y contexto
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Variables de simulación
  let s, U, Uprev, u, uprev, v, r, theta;
  let isRunning = false;

  // Logs y datos para ML
  let mlAlertsCount = 0;
  let discoveryAlertsCount = 0;

  // --- Funciones básicas simulación ---
  function initArrays(cfg, seed) {
    s = new Float64Array(N);
    U = new Float64Array(N);
    Uprev = new Float64Array(N);
    u = new Float64Array(N);
    uprev = new Float64Array(N);
    v = new Float64Array(N);
    r = new Float64Array(N);
    theta = new Float64Array(N);
    for(let j=0; j<N; j++) {
      s[j] = j;
      U[j] = (Math.random()-0.5)*0.02*seed;
      Uprev[j] = U[j];
      u[j] = 0;
      uprev[j] = 0;
      v[j] = 0;
      theta[j] = (j/(N-1))*cfg.thetaTot;
      r[j] = cfg.a*theta[j];
    }
  }

  function grad(arr,j){
    if(j<=0) return arr[1]-arr[0];
    if(j>=arr.length-1) return arr[arr.length-1]-arr[arr.length-2];
    return (arr[j+1]-arr[j-1])/2;
  }
  function lap(arr,j){
    if(j<=0) return arr[1]-2*arr[0]+arr[0];
    if(j>=arr.length-1) return arr[arr.length-1]-2*arr[arr.length-2]+arr[arr.length-1];
    return arr[j+1]-2*arr[j]+arr[j-1];
  }

  function step(cfg, dt){
    const N = cfg.N;
    const eps = new Float64Array(N);
    const c = new Float64Array(N);
    for(let j=0;j<N;j++) {
      const divu = grad(u,j);
      eps[j] = 1.0 + cfg.alpha*divu + cfg.beta*U[j]*U[j];
      c[j] = 1/Math.sqrt(eps[j]);
    }
    const newU = new Float64Array(N);
    for(let j=1;j<N-1;j++) {
      const lapU = lap(U,j);
      const dUd = (U[j] - Uprev[j])/dt;
      newU[j] = 2*U[j] - Uprev[j] + dt*dt*(c[j]*c[j]*lapU - 2*cfg.gamma*dUd) - dt*dt*cfg.kappa*U[j];
    }
    newU[0] = 0;
    newU[N-1] = 0;

    for(let j=1;j<N-1;j++) {
      if(Math.abs(newU[j]-U[j]) > cfg.Uth) cfg.jumps++;
    }

    for(let j=0;j<N;j++) {
      Uprev[j] = U[j];
      U[j] = newU[j];
    }

    for(let j=1;j<N-1;j++) {
      const lapu = lap(u,j);
      const T = U[j]*U[j];
      const dtt_u = lapu + T;
      u[j] += dt*dt*dtt_u - dt*cfg.eta*u[j];
    }
  }

  function extractFeatures(log){
    const Uabs = log.U.map(x => Math.abs(x));
    const maxEnergy = Math.max(...Uabs);
    const focalDuration = log.focalDuration;
    const jumps = log.jumps;

    const sumU = Uabs.reduce((a,b)=>a+b,0);
    const p = Uabs.map(x=>x/sumU);
    let entropy = 0;
    for(let v of p){
      if(v>0) entropy -= v*Math.log(v);
    }

    return [maxEnergy, focalDuration, jumps, entropy];
  }

  function kmeans(data, k, maxIter=50) {
    const centers = [];
    for(let i=0;i<k;i++) {
      centers.push(data[Math.floor(Math.random()*data.length)].slice());
    }

    let labels = new Array(data.length).fill(0);
    for(let iter=0;iter<maxIter;iter++) {
      for(let i=0;i<data.length;i++) {
        let bestDist = Infinity;
        let bestC = 0;
        for(let c=0;c<k;c++) {
          let dist = 0;
          for(let d=0;d<data[i].length;d++) {
            dist += (data[i][d]-centers[c][d])**2;
          }
          if(dist<bestDist){
            bestDist=dist;
            bestC=c;
          }
        }
        labels[i] = bestC;
      }
      const sums = Array(k).fill(null).map(()=>Array(data[0].length).fill(0));
      const counts = Array(k).fill(0);
      for(let i=0;i<data.length;i++) {
        const c = labels[i];
        counts[c]++;
        for(let d=0;d<data[0].length;d++) {
          sums[c][d]+=data[i][d];
        }
      }
      for(let c=0;c<k;c++){
        if(counts[c]>0) {
          for(let d=0;d<data[0].length;d++) {
            centers[c][d] = sums[c][d]/counts[c];
          }
        }
      }
    }
    return {centers, labels};
  }

  function detectOutliers(labels) {
    const counts = {};
    labels.forEach(l => { counts[l] = (counts[l] || 0) + 1; });
    const outliers = [];
    for(let i=0;i<labels.length;i++) {
      if(counts[labels[i]] < 3) outliers.push(i);
    }
    return outliers;
  }

  // -------- Protocolo avanzado de descubrimiento --------

  class DiscoveryProtocol {
    constructor() {
      this.patterns = [];
      this.minRepetitions = 3;
      this.similarityThreshold = 0.12;
      this.distanceNoveltyThreshold = 0.7;
      this.noveltyScoreThreshold = 0.7;
      this.globalFeaturesStats = {mean: null, std: null};
    }

    distance(a,b) {
      let sum = 0;
      for(let i=0; i<a.length; i++) sum += (a[i]-b[i])**2;
      return Math.sqrt(sum);
    }

    registerPattern(params, features) {
      this.patterns.push({params, features});
    }

    groupSimilarPatterns() {
      const groups = [];
      for(const p of this.patterns) {
        let foundGroup = false;
        for(const g of groups) {
          if(this.distance(p.params, g[0].params) < this.similarityThreshold) {
            g.push(p);
            foundGroup = true;
            break;
          }
        }
        if(!foundGroup) groups.push([p]);
      }
      return groups;
    }

    meanStd(arr) {
      const n = arr.length;
      const mean = arr.reduce((a,b)=>a+b,0)/n;
      const variance = arr.reduce((a,b)=>a+(b-mean)**2,0)/n;
      return [mean, Math.sqrt(variance)];
    }

    tTest(groupFeatures, globalMean, globalStd) {
      const n = groupFeatures.length;
      if(n < 2) return 1;
      const meanGroup = groupFeatures.reduce((a,b)=>a+b,0)/n;
      const se = globalStd/Math.sqrt(n);
      const t = Math.abs(meanGroup - globalMean) / se;
      return (t>2) ? 0.01 : 1;
    }

    updateGlobalStats(allFeatures) {
      const n = allFeatures.length;
      if(n===0) return;
      const dims = allFeatures[0].length;
      const mean = new Array(dims).fill(0);
      const variance = new Array(dims).fill(0);
      for(let d=0; d<dims; d++){
        for(let i=0;i<n;i++) mean[d]+=allFeatures[i][d];
        mean[d]/=n;
        for(let i=0;i<n;i++) variance[d]+=(allFeatures[i][d]-mean[d])**2;
        variance[d]/=n;
      }
      const std = variance.map(Math.sqrt);
      this.globalFeaturesStats.mean = mean;
      this.globalFeaturesStats.std = std;
    }

    evaluateNovelty() {
      if(this.patterns.length < this.minRepetitions) return {alert:false};
      const groups = this.groupSimilarPatterns();
      for(const g of groups) {
        if(g.length < this.minRepetitions) continue;

        // Evaluamos solo la primer feature (maxEnergy) por simplicidad
        const featuresArr = g.map(p => p.features[0]);
        const globalMean = this.globalFeaturesStats.mean ? this.globalFeaturesStats.mean[0] : 0;
        const globalStd = this.globalFeaturesStats.std ? this.globalFeaturesStats.std[0] : 1;
        const pValue = this.tTest(featuresArr, globalMean, globalStd);
        if(pValue > 0.05) continue;

        // Distancia mínima a otros grupos (seguridad)
        let minDist = Infinity;
        for(const otherGroup of groups) {
          if(otherGroup === g) continue;
          const dist = this.distance(g[0].features, otherGroup[0].features);
          if(dist < minDist) minDist = dist;
        }
        if(minDist < this.distanceNoveltyThreshold) continue;

        const persistNorm = Math.min(1, g.length / 10);
        const distNorm = Math.min(1, minDist / 2);
        const noveltyScore = 0.4 * persistNorm + 0.4 * (1-pValue) + 0.2 * distNorm;

        if(noveltyScore > this.noveltyScoreThreshold) {
          return {alert:true, noveltyScore, group:g};
        }
      }
      return {alert:false};
    }
  }

  // -------- Variables globales y setup --------
  const discoveryProtocol = new DiscoveryProtocol();
  let simulationData = [];
  let currentSimulationIndex = 0;

  // Genera todas combinaciones de parámetros
  function generateParamCombinations(grid) {
    const keys = Object.keys(grid);
    const combos = [];

    function backtrack(i, acc) {
      if(i===keys.length) {
        combos.push(Object.values(acc));
        return;
      }
      const key = keys[i];
      for(const val of grid[key]) {
        acc[key] = val;
        backtrack(i+1, acc);
      }
    }
    backtrack(0,{});
    return combos;
  }

  const allParamCombinations = generateParamCombinations(paramGrid);
  const totalSims = allParamCombinations.length * seedsCount;
  totalSimsSpan.textContent = totalSims;

  // Simulación completa con parámetros y seed
  async function runSimulation(params, seed) {
    const [alpha, beta, kappa, Uth, dr] = params;
    const cfg = {
      N, alpha, beta, kappa, Uth, dr,
      a: 0.4, thetaTot: 20 * Math.PI,
      gamma: 0.01, eta: 0.01,
      jumps: 0
    };
    initArrays(cfg, seed);
    const dt = 0.1;
    let maxEnergy = 0;
    let focalDuration = 0;

    for(let t=0; t<stepsPerSim; t++) {
      step(cfg, dt);
      // Energia max
      const maxU = Math.max(...U.map(x => Math.abs(x)));
      if(maxU > maxEnergy) maxEnergy = maxU;
    }

    // Simulamos duración focalizada (ejemplo simple)
    focalDuration = stepsPerSim / 10;

    return {
      params,
      seed,
      U: Array.from(U),
      maxEnergy,
      focalDuration,
      jumps: cfg.jumps,
      features: []
    };
  }

  function logAlert(text) {
    const d = new Date();
    alertsDiv.innerHTML += `<div class="alert">[${d.toLocaleTimeString()}] ${text}</div>`;
    alertsDiv.scrollTop = alertsDiv.scrollHeight;
    discoveryAlertsCount++;
    discAlertsCountSpan.textContent = discoveryAlertsCount;
  }

  function drawSimulation() {
    ctx.clearRect(0,0,W,H);
    ctx.beginPath();
    ctx.strokeStyle = '#66ccee';
    for(let j=0;j<N;j++) {
      const x = (j/(N-1)) * W;
      const y = H/2 - U[j]*200;
      if(j===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  async function runAllSimulations() {
    isRunning = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    simulationData = [];
    discoveryAlertsCount = 0;
    currentSimulationIndex = 0;
    discoveryProtocol.patterns = [];
    discoveryProtocol.globalFeaturesStats = {mean: null, std: null};

    for(let i=0; i<allParamCombinations.length && isRunning; i++) {
      for(let seed=1; seed<=seedsCount && isRunning; seed++) {
        currentSimulationIndex++;
        currentSimSpan.textContent = currentSimulationIndex;

        const simResult = await runSimulation(allParamCombinations[i], seed);
        simulationData.push(simResult);

        // Extraer features
        const features = extractFeatures(simResult);
        simResult.features = features;

        // Registrar patrón raro si es outlier
        if(simulationData.length >= 20) {
          const allFeatures = simulationData.map(s => s.features);
          const kmres = kmeans(allFeatures, 3);
          const outliersIdx = detectOutliers(kmres.labels);

          // Registrar patrones outliers
          for(const idx of outliersIdx) {
            const s = simulationData[idx];
            discoveryProtocol.registerPattern(s.params, s.features);
          }

          // Actualizar stats globales y evaluar descubrimiento
          discoveryProtocol.updateGlobalStats(allFeatures);
          const evaluation = discoveryProtocol.evaluateNovelty();

          // Si es descubrimiento, lanzar alerta definitiva
          if(evaluation.alert) {
            const score = evaluation.noveltyScore.toFixed(3);
            logAlert(`¡DESCUBRIMIENTO CIENTÍFICO DETECTADO! Score: ${score} | Parámetros: α=${evaluation.group[0].params[0]}, β=${evaluation.group[0].params[1]}, κ=${evaluation.group[0].params[2]}, Uth=${evaluation.group[0].params[3]}, dr=${evaluation.group[0].params[4]}`);
          }
        }

        // Dibujar última simulación
        for(let j=0;j<N;j++) {
          U[j] = simResult.U[j];
        }
        drawSimulation();
      }
    }
    btnStart.disabled = false;
    btnStop.disabled = true;
    isRunning = false;
  }

  btnStart.onclick = () => {
    if(isRunning) return;
    runAllSimulations();
  };
  btnStop.onclick = () => {
    isRunning = false;
  };
})();
</script>
</body>
</html>
